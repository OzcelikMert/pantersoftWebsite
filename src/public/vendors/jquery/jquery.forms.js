//jquery.serializeObject.js
(function($){$.fn.serializeObject = function(){var self = this, json = {}, push_counters = {}, patterns = {		"validate": /^[a-zA-Z][a-zA-Z0-9_]*(?:\[(?:\d*|[a-zA-Z0-9_]+)\])*$/,		"key":      /[a-zA-Z0-9_]+|(?=\[\])/g,		"push":     /^$/,		"fixed":    /^\d+$/,		"named":    /^[a-zA-Z0-9_]+$/	};this.build = function(base, key, value){base[key] = value;return base;};this.push_counter = function(key){if(push_counters[key] === undefined){		push_counters[key] = 0;	}return push_counters[key]++;};$.each($(this).serializeArray(), function(){if(!patterns.validate.test(this.name)){		return;	}var k, keys = this.name.match(patterns.key), merge = (this.value === "on") ? true : this.value, reverse_key = this.name;while((k = keys.pop()) !== undefined){		reverse_key = reverse_key.replace(new RegExp("\\[" + k + "\\]$"), '');		if(k.match(patterns.push)){merge = self.build([], self.push_counter(reverse_key), merge);}	else if(k.match(patterns.fixed)){merge = self.build([], k, merge);}	else if(k.match(patterns.named)){merge = self.build({}, k, merge);}	}json = $.extend(true, json, merge);});return json;};})(jQuery);
//jquery.formautofill.js
(function($){$.fn.extend({autofill: function(data, options) {		self = this;		return this.each(function() {		$.each( data, function(k, v) {		function set(_k, _v, type = 0){		var selector, elt;		selector = `[name="${_k}${((type === 1) ? `[]` : ``)}"]${((type === 1) ? `[value="${_v}"]` : ``)}`;		elt = self.find( selector );		if ( elt.length === 1 ) {if(elt.attr("type") === "checkbox") elt.prop("checked", (type === 1) ? 1 : _v); else elt.val( _v );} else if ( elt.length > 1 ) {elt.val([_v]);}	}			if(Array.isArray(v)){v.forEach(_v => {set(k, _v, 1);});}else{set(k, v);}	});	});	}});})(jQuery);

